import Joi from 'joi';
import cron from 'node-cron';
import _ from 'lodash';

const validActions = ['slack-webhook', 'discord-webhook', 'custom-request', 'crisis-webhook'];

/**
 * Custom validation function to insure that the trigger is valid based on the monitor type
 * @param {*} value
 * @param {*} helpers
 * @returns the value if it is valid, otherwise a joi error
*/
function validateTrigger(value, helpers) {
    const type = helpers.state.ancestors[0].type;
    switch (type) {
        case 'cron':
            // the trigger must be a string, and a valid cron expression
            if (typeof value !== 'string') {
                return helpers.error('any.invalid', { type, value, message: 'if \"monitor.type\" is \"cron\",\"monitor.trigger\" must be a string' });
            }
            if (!cron.validate(value)) {
                return helpers.error('any.invalid', { type, value, message: 'if \"monitor.type\" is \"cron\",\"monitor.trigger\" must be a valid cron expression' });
            }
            return value;

        case 'event':
            // the trigger must be an array, and all elements must be strings
            if (!Array.isArray(value)) {
                return helpers.error('any.invalid', { type, value, message: 'if \"monitor.type\" is \"event\",\"monitor.trigger\" must be an array' });
            }
            if (!value.every((element) => typeof element === 'string')) {
                return helpers.error('any.invalid', { type, value, message: 'if \"monitor.type\" is \"event\",all elements of \"monitor.trigger\" must be strings' });
            }
            return value;
    }
}


/**
 * Schema for creating a monitor (POST method)
 * - monitor.type can be cron, event or dryRun
 * - depending on the type, monitor.trigger has different requirements
 * - depending on the type, some fields are required or optional
 */
const forCreation = Joi.object({
    "_id": Joi.any().strip(),       //ingored, will be generated by the database
    createdAt: Joi.any().strip(),   //ignored, will be generated by the database
    updatedAt: Joi.any().strip(),   //ignored, will be generated by the database

    firstElement: Joi.object({
        name: Joi.string().required(),
        filter: Joi.object().optional(),
        layerInfo: Joi.any().strip() //ignored, will be generated by the evaluation
    }).required(),

    secondElement: Joi.object({
        name: Joi.string().required(),
        filter: Joi.object().optional(),
        layerInfo: Joi.any().strip() //ignored, will be generated by the evaluation
    }).required(),

    monitor: Joi.object({
        name: Joi.string().when('type', { is: 'dryRun', then: Joi.optional(), otherwise: Joi.required() }),
        description: Joi.string().default(''),
        type: Joi.string().valid('cron', 'event', 'dryRun').required(),
        enabled: Joi.boolean().default(true),  
        // if the type is cron, trigger is required and needs to be a string that is a valid cron expression
        // if the type is event, trigger is required and needs to be an array of strings
        // if the type is dryRun, trigger is optional (not needed) 
        trigger: Joi.custom(validateTrigger)
        .when('type', {
            is: 'dryRun',
            then: Joi.optional(),
            otherwise: Joi.required()
        }),
        
        lastRun: Joi.any().strip(),

        evaluation: Joi.object({
            alertOn : Joi.string().valid('noData', 'data').default('data'),
            type: Joi.string().required(),
            maxDistance: Joi.number().positive().optional(),
            minDistance: Joi.number().positive().optional(),
        }).required(),

        action: Joi.object({
            type: Joi.string().valid(...validActions).required(),
            cooldown: Joi.number().positive().default(60),
            url: Joi.string().uri().required(),

            crisisProperties: Joi.object({
                organisation: Joi.string().required(),
                template : Joi.string().required(),
                token: Joi.string().required(),
            }).when('type', {
                is: 'crisis-webhook',
                then: Joi.required(),
                otherwise: Joi.forbidden()
            }),

            customProperties: Joi.object({
                method: Joi.string().valid('GET', 'POST', 'PUT', 'DELETE').default('POST'),
                headers: Joi.object().default({}),
                body: Joi.object().default({})
            }).when('type', {
                is: 'custom-request',
                then: Joi.optional(),
                otherwise: Joi.forbidden()
            }).default({})

        }).default({})
    }).required()
});

/**
 * Schema for updating a monitor (PUT method)
 * - monitor.type can be cron or event (not dryRun)
 */
const forUpdate = Joi.object({
    "_id": Joi.any().strip(),       //ingored, will be generated by the database
    createdAt: Joi.any().strip(),   //ignored, will be generated by the database
    updatedAt: Joi.any().strip(),   //ignored, will be generated by the database

    firstElement: Joi.object({
        name: Joi.string().required(),
        filter: Joi.object().optional(),
        layerInfo: Joi.any().strip() //ignored, will be generated by the evaluation
    }).required(),

    secondElement: Joi.object({
        name: Joi.string().required(),
        filter: Joi.object().optional(),
        layerInfo: Joi.any().strip() //ignored, will be generated by the evaluation
    }).required(),

    monitor: Joi.object({
        name: Joi.string().required(),
        description: Joi.string().required(),
        type: Joi.string().valid('cron', 'event').required(),
        // Since this is an update(PUT) method, we won't accept default values
        enabled: Joi.boolean().required(),
        trigger: Joi.custom(validateTrigger).required(),
        lastRun: Joi.any().strip(), //ignored, will be generated by the evaluation

        evaluation: Joi.object({
            alertOn : Joi.string().valid('noData', 'data').default('data'),
            type: Joi.string().required(),
            maxDistance: Joi.number().positive().optional(),
            minDistance: Joi.number().positive().optional(),
        }).required(),

        action : Joi.object({
            type: Joi.string().valid(...validActions).required(),
            cooldown: Joi.number().positive().default(60),
            url: Joi.string().uri().required(),

            crisisProperties: Joi.object({
                organisation: Joi.string().required(),
                template : Joi.string().required(),
                token: Joi.string().required(),
            }).when('type', {
                is: 'crisis-webhook',
                then: Joi.required(),
                otherwise: Joi.forbidden()
            }),

            customProperties: Joi.object({
                method: Joi.string().valid('GET', 'POST', 'PUT', 'DELETE').default('POST'),
                headers: Joi.object().default({}),
                body: Joi.object().default({})
            }).when('type', {
                is: 'custom-request',
                then: Joi.optional(),
                otherwise: Joi.forbidden()
            }).default({})

        }).default({})
    }).required()
});

/**
 * validate a patch schema based on the current monitor object defining default values
 * @param {*} currentMonitor 
 * @returns the validation result
 */
function validatePatchSchema(currentMonitor,newData){

    // We define the default values for type and trigger since they are dependent on each other
    // and we need verify that if we change the type, the trigger is compatible
    _.set(newData, 'monitor.type', _.get(newData, 'monitor.type', currentMonitor.monitor.type));
    _.set(newData, 'monitor.trigger', _.get(newData, 'monitor.trigger', currentMonitor.monitor.trigger));


    const schema =  Joi.object({
        "_id": Joi.any().strip(),       //ingored, will be generated by the database
        createdAt: Joi.any().strip(),   //ingored, will be generated by the database
        updatedAt: Joi.any().strip(),   //ingored, will be generated by the database
    
        firstElement: Joi.object({
            name: Joi.string().default(currentMonitor.firstElement.name),
            filter: Joi.object().optional(), // we can remove the filter if needed
            layerInfo: Joi.any().strip()    //ignored, will be generated by the evaluation
        }).default(currentMonitor.firstElement),

        secondElement: Joi.object({
            name: Joi.string().default(currentMonitor.secondElement.name),
            filter: Joi.object().optional(), // we can remove the filter if needed
            layerInfo: Joi.any().strip()    //ignored, will be generated by the evaluation
        }).default(currentMonitor.secondElement),

        monitor: Joi.object({
            name: Joi.string().default(currentMonitor.monitor.name),
            description: Joi.string().default(currentMonitor.monitor.description),
            type: Joi.string().valid('cron', 'event').required(),
            trigger: Joi.custom(validateTrigger).required(),
            enabled: Joi.boolean().default(currentMonitor.monitor.enabled),
            lastRun: Joi.any().strip(),     //ignored, will be generated by the evaluation

            evaluation: Joi.object({
                alertOn : Joi.string().valid('noData', 'data').default(currentMonitor.monitor.evaluation.alertOn),
                type: Joi.string().default(currentMonitor.monitor.evaluation.type),
                maxDistance: Joi.number().positive().optional(),
                minDistance: Joi.number().positive().optional(),
            }).default(currentMonitor.monitor.evaluation),

            action : Joi.object({
                type: Joi.string().valid(...validActions).default(currentMonitor.monitor.action?.type),
                cooldown: Joi.number().positive().default(currentMonitor.monitor.action?.cooldown),
                url: Joi.string().uri().default(currentMonitor.monitor.action?.url),

                // NEEDS TO BE REFINED
                crisisProperties: Joi.object({
                    organisation: Joi.string().default(currentMonitor.monitor.action?.crisisProperties?.organisation),
                    template : Joi.string().default(currentMonitor.monitor.action?.crisisProperties?.template),
                    token: Joi.string().default(currentMonitor.monitor.action?.crisisProperties?.token),
                }).when('type', {
                    is: 'crisis-webhook',
                    then: Joi.required(),
                    otherwise: Joi.forbidden()
                }).default(currentMonitor.monitor.action?.crisisProperties),

                customProperties: Joi.object({
                    method: Joi.string().valid('GET', 'POST', 'PUT', 'DELETE').default('POST'),
                    headers: Joi.object().default(currentMonitor.monitor.action?.customProperties?.headers),
                    body: Joi.object().default(currentMonitor.monitor.action?.customProperties?.body)
                }).when('type', {
                    is: 'custom-request',
                    then: Joi.optional(),
                    otherwise: Joi.forbidden()
                }).default(currentMonitor.monitor.action?.customProperties),

            }).default(currentMonitor.monitor.action),
        }).default(currentMonitor.monitor)
    });
    return schema.validate(newData);
}



export default {
    forCreation,
    forUpdate,
    validatePatchSchema
};

